# DesignPattern
设计模式理解<br/>
1.Factory解决问题<br/>
  使类的实例化过程可以管理，通过工厂方法，隔离了真实类和用户，接触用户和类之间的耦合<br/>
  缺点：<br/>
  会导致工厂泛滥<br/>
2.AbstractFactory解决问题：<br/>
  解决了系列产品的生产问题，解决了工厂泛滥的问题<br/>
  缺点：<br/>
  没有工厂灵活，需要填加系列品类是需要改变抽象工厂的接口<br/>
  （使用spring bean工厂完美解决上述缺点）<br/>
3.fliter解决问<br/>
  责任传递，和信息流处理流水线<br/>
4.bradge解决问题<br/>
  当类在两个维度有扩展，且这两个维度有交叉<br/>
5.command解决问题<br/>
  将命令封装成对象，自己可以执行，这样可以将命令发送给任意对象执行<br/>
6.State解决问题<br/>
  类继承相同的抽象类或者实现相同的接口，定义不同的状态类相同的方法实现不同的逻辑处理（个人觉得可以应用于协议状态机）<br/>
7.proxy解决问题<br/>
  静态代理可以通过继承或者聚合实现对某个类的代理，可应用与日志，性能测试，拦截过滤，权限检查，等等<br/>
  动态代理实现了对任意类的任意方法创建任意种类的代理<br/>
8.Strategy解决问题<br/>
  相同逻辑处理不同的不同策略的问题，通过聚合策略类的引用或者父类，完成对于不同策略的处理<br/>
9.Iterate解决问题<br/>
  主要完成对集合类的遍历工作<br/>
10.门面模式（中介者模式，调停者模式）<br/>
  多个类之间关系错综复杂的时候，通过将所有类的和统一类交互，并持有这个类的引用来解决类之间的耦合关系<br/>

